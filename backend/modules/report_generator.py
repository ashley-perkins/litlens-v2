import os
import json
import logging
from typing import List, Dict, Any, Optional, Union
from dataclasses import dataclass
from enum import Enum
from abc import ABC, abstractmethod
from datetime import datetime
from pathlib import Path

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class ReportFormat(Enum):
    """Enumeration of supported report formats."""
    TEXT = "txt"
    MARKDOWN = "md"
    HTML = "html"
    JSON = "json"
    PDF = "pdf"


@dataclass
class ReportConfig:
    """Configuration for report generation."""
    format: ReportFormat = ReportFormat.MARKDOWN
    include_toc: bool = True
    include_metadata: bool = True
    include_statistics: bool = True
    template_path: Optional[str] = None
    output_encoding: str = "utf-8"
    max_summary_length: int = 500
    include_timestamps: bool = True
    custom_css: Optional[str] = None
    paper_numbering: bool = True
    section_numbering: bool = True


@dataclass
class ReportMetadata:
    """Metadata for the report."""
    generated_at: datetime
    total_papers: int
    total_sections: int
    research_goal: str
    generator_version: str = "1.0.0"
    processing_time: Optional[float] = None


class ReportTemplate(ABC):
    """Abstract base class for report templates."""
    
    @abstractmethod
    def generate_header(self, goal: str, metadata: ReportMetadata) -> str:
        """Generate report header."""
        pass
    
    @abstractmethod
    def generate_toc(self, summaries: List[Dict[str, Any]]) -> str:
        """Generate table of contents."""
        pass
    
    @abstractmethod
    def generate_paper_section(self, paper: Dict[str, Any], index: int) -> str:
        """Generate section for a single paper."""
        pass
    
    @abstractmethod
    def generate_footer(self, metadata: ReportMetadata) -> str:
        """Generate report footer."""
        pass


class MarkdownTemplate(ReportTemplate):
    """Markdown report template."""
    
    def __init__(self, config: ReportConfig):
        self.config = config
    
    def generate_header(self, goal: str, metadata: ReportMetadata) -> str:
        """Generate markdown header."""
        header = ["# LitLens Summary Report"]
        
        if self.config.include_timestamps:
            header.append(f"*Generated on: {metadata.generated_at.strftime('%Y-%m-%d %H:%M:%S')}*")
        
        header.extend([
            "",
            "## Research Goal",
            "",
            goal,
            ""
        ])
        
        if self.config.include_statistics:
            header.extend([
                "## Statistics",
                "",
                f"- **Total Papers**: {metadata.total_papers}",
                f"- **Total Sections**: {metadata.total_sections}",
                f"- **Generated by**: LitLens v{metadata.generator_version}",
                ""
            ])
        
        return "\n".join(header)
    
    def generate_toc(self, summaries: List[Dict[str, Any]]) -> str:
        """Generate markdown table of contents."""
        if not self.config.include_toc:
            return ""
        
        toc = ["## Table of Contents", ""]
        
        for i, paper in enumerate(summaries, 1):
            title = paper.get('title', f"Paper {i}")
            metadata = paper.get("metadata", {})
            
            # Paper link
            toc.append(f"{i}. [{title}](#paper-{i})")
            
            # Metadata
            if self.config.include_metadata:
                meta_line = self._format_metadata(metadata)
                if meta_line:
                    toc.append(f"   - {meta_line}")
            
            # Sections
            chunks = paper.get("chunks", [])
            seen_sections = set()
            for chunk in chunks:
                section_title = chunk.get('title', 'Untitled Section').strip()
                if section_title and section_title not in seen_sections:
                    seen_sections.add(section_title)
                    toc.append(f"   - {section_title}")
        
        toc.extend(["", "---", ""])
        return "\n".join(toc)
    
    def generate_paper_section(self, paper: Dict[str, Any], index: int) -> str:
        """Generate markdown section for a paper."""
        title = paper.get('title', f"Paper {index}")
        metadata = paper.get("metadata", {})
        summary = paper.get("summary", "[No summary available]")
        
        section = [f"## Paper {index}: {title}"]
        
        if self.config.include_metadata:
            meta_line = self._format_metadata(metadata)
            if meta_line:
                section.append(f"*{meta_line}*")
        
        section.extend(["", summary.strip(), ""])
        
        return "\n".join(section)
    
    def generate_footer(self, metadata: ReportMetadata) -> str:
        """Generate markdown footer."""
        footer = [
            "---",
            "",
            f"*Report generated by LitLens v{metadata.generator_version}*"
        ]
        
        if metadata.processing_time:
            footer.append(f"*Processing time: {metadata.processing_time:.2f} seconds*")
        
        return "\n".join(footer)
    
    def _format_metadata(self, metadata: Dict[str, Any]) -> str:
        """Format metadata for display."""
        meta_parts = []
        
        if metadata.get("year"):
            meta_parts.append(f"Year: {metadata['year']}")
        if metadata.get("journal"):
            meta_parts.append(f"Journal: {metadata['journal']}")
        if metadata.get("authors"):
            authors = metadata['authors']
            if isinstance(authors, list):
                authors = ", ".join(authors[:3])  # Limit to first 3 authors
                if len(metadata['authors']) > 3:
                    authors += " et al."
            meta_parts.append(f"Authors: {authors}")
        
        return " | ".join(meta_parts)


class HTMLTemplate(ReportTemplate):
    """HTML report template."""
    
    def __init__(self, config: ReportConfig):
        self.config = config
    
    def generate_header(self, goal: str, metadata: ReportMetadata) -> str:
        """Generate HTML header."""
        css = self.config.custom_css or self._default_css()
        
        header = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LitLens Summary Report</title>
    <style>
{css}
    </style>
</head>
<body>
    <header>
        <h1>LitLens Summary Report</h1>
        <div class="metadata">
            <p><strong>Research Goal:</strong> {goal}</p>
            <p><strong>Generated:</strong> {metadata.generated_at.strftime('%Y-%m-%d %H:%M:%S')}</p>
            <p><strong>Total Papers:</strong> {metadata.total_papers}</p>
        </div>
    </header>
    <main>
"""
        return header
    
    def generate_toc(self, summaries: List[Dict[str, Any]]) -> str:
        """Generate HTML table of contents."""
        if not self.config.include_toc:
            return ""
        
        toc = ['<nav class="toc">', '<h2>Table of Contents</h2>', '<ul>']
        
        for i, paper in enumerate(summaries, 1):
            title = paper.get('title', f"Paper {i}")
            toc.append(f'<li><a href="#paper-{i}">{title}</a></li>')
        
        toc.extend(['</ul>', '</nav>'])
        return "\n".join(toc)
    
    def generate_paper_section(self, paper: Dict[str, Any], index: int) -> str:
        """Generate HTML section for a paper."""
        title = paper.get('title', f"Paper {index}")
        metadata = paper.get("metadata", {})
        summary = paper.get("summary", "[No summary available]")
        
        section = f"""
        <section id="paper-{index}" class="paper">
            <h2>Paper {index}: {title}</h2>
            <div class="paper-metadata">
                {self._format_metadata_html(metadata)}
            </div>
            <div class="paper-summary">
                {summary.strip()}
            </div>
        </section>
        """
        
        return section
    
    def generate_footer(self, metadata: ReportMetadata) -> str:
        """Generate HTML footer."""
        footer = f"""
    </main>
    <footer>
        <p>Report generated by LitLens v{metadata.generator_version}</p>
        {f'<p>Processing time: {metadata.processing_time:.2f} seconds</p>' if metadata.processing_time else ''}
    </footer>
</body>
</html>
"""
        return footer
    
    def _format_metadata_html(self, metadata: Dict[str, Any]) -> str:
        """Format metadata as HTML."""
        if not metadata:
            return ""
        
        html_parts = []
        
        if metadata.get("year"):
            html_parts.append(f"<span class='year'>Year: {metadata['year']}</span>")
        if metadata.get("journal"):
            html_parts.append(f"<span class='journal'>Journal: {metadata['journal']}</span>")
        if metadata.get("authors"):
            authors = metadata['authors']
            if isinstance(authors, list):
                authors = ", ".join(authors[:3])
                if len(metadata['authors']) > 3:
                    authors += " et al."
            html_parts.append(f"<span class='authors'>Authors: {authors}</span>")
        
        return " | ".join(html_parts)
    
    def _default_css(self) -> str:
        """Default CSS for HTML reports."""
        return """
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            background-color: #f4f4f4;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 30px;
        }
        
        .metadata {
            margin-top: 15px;
            color: #666;
        }
        
        .toc {
            background-color: #f9f9f9;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 30px;
        }
        
        .toc ul {
            list-style-type: none;
            padding-left: 0;
        }
        
        .toc li {
            margin: 10px 0;
        }
        
        .paper {
            margin-bottom: 40px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        .paper-metadata {
            color: #666;
            font-style: italic;
            margin-bottom: 15px;
        }
        
        .paper-summary {
            text-align: justify;
        }
        
        footer {
            margin-top: 40px;
            padding: 20px;
            background-color: #f4f4f4;
            border-radius: 5px;
            text-align: center;
            color: #666;
        }
        """


class JSONTemplate(ReportTemplate):
    """JSON report template."""
    
    def __init__(self, config: ReportConfig):
        self.config = config
    
    def generate_header(self, goal: str, metadata: ReportMetadata) -> str:
        return ""
    
    def generate_toc(self, summaries: List[Dict[str, Any]]) -> str:
        return ""
    
    def generate_paper_section(self, paper: Dict[str, Any], index: int) -> str:
        return ""
    
    def generate_footer(self, metadata: ReportMetadata) -> str:
        return ""
    
    def generate_full_report(self, summaries: List[Dict[str, Any]], goal: str, metadata: ReportMetadata) -> str:
        """Generate complete JSON report."""
        report_data = {
            "metadata": {
                "generated_at": metadata.generated_at.isoformat(),
                "total_papers": metadata.total_papers,
                "total_sections": metadata.total_sections,
                "research_goal": goal,
                "generator_version": metadata.generator_version,
                "processing_time": metadata.processing_time
            },
            "research_goal": goal,
            "papers": summaries
        }
        
        return json.dumps(report_data, indent=2, ensure_ascii=False)


class EnhancedReportGenerator:
    """Enhanced report generator with multiple formats and templates."""
    
    def __init__(self, config: Optional[ReportConfig] = None):
        self.config = config or ReportConfig()
        self.template_map = {
            ReportFormat.MARKDOWN: MarkdownTemplate,
            ReportFormat.HTML: HTMLTemplate,
            ReportFormat.JSON: JSONTemplate,
            ReportFormat.TEXT: MarkdownTemplate,  # Use markdown template for text
        }
    
    def generate_report(
        self,
        summaries: List[Dict[str, Any]],
        goal: str,
        output_path: Optional[str] = None,
        return_as_string: bool = False
    ) -> Optional[str]:
        """Generate report with enhanced features."""
        start_time = datetime.now()
        
        # Create metadata
        metadata = ReportMetadata(
            generated_at=start_time,
            total_papers=len(summaries),
            total_sections=sum(len(paper.get("chunks", [])) for paper in summaries),
            research_goal=goal
        )
        
        # Get template
        template_class = self.template_map.get(self.config.format)
        if not template_class:
            raise ValueError(f"Unsupported format: {self.config.format}")
        
        template = template_class(self.config)
        
        # Generate report content
        if self.config.format == ReportFormat.JSON:
            content = template.generate_full_report(summaries, goal, metadata)
        else:
            content_parts = [
                template.generate_header(goal, metadata),
                template.generate_toc(summaries)
            ]
            
            # Generate paper sections
            for i, paper in enumerate(summaries, 1):
                content_parts.append(template.generate_paper_section(paper, i))
            
            # Calculate processing time
            end_time = datetime.now()
            metadata.processing_time = (end_time - start_time).total_seconds()
            
            content_parts.append(template.generate_footer(metadata))
            content = "\n".join(content_parts)
        
        if return_as_string:
            return content
        
        # Determine output path
        if output_path is None:
            output_path = f"litlens_summary_report.{self.config.format.value}"
        else:
            # Fix extension if needed
            output_path = self._fix_extension(output_path)
        
        # Write to file
        try:
            with open(output_path, "w", encoding=self.config.output_encoding) as f:
                f.write(content)
            
            logger.info(f"Report saved as: {output_path}")
            return output_path
        
        except Exception as e:
            logger.error(f"Failed to save report: {e}")
            return None
    
    def _fix_extension(self, output_path: str) -> str:
        """Fix file extension based on format."""
        path = Path(output_path)
        expected_ext = f".{self.config.format.value}"
        
        if path.suffix != expected_ext:
            return str(path.with_suffix(expected_ext))
        
        return output_path
    
    def generate_multiple_formats(
        self,
        summaries: List[Dict[str, Any]],
        goal: str,
        formats: List[ReportFormat],
        base_output_path: str = "litlens_summary_report"
    ) -> Dict[ReportFormat, str]:
        """Generate reports in multiple formats."""
        results = {}
        
        for fmt in formats:
            # Create new config with different format
            config = ReportConfig(
                format=fmt,
                include_toc=self.config.include_toc,
                include_metadata=self.config.include_metadata,
                include_statistics=self.config.include_statistics
            )
            
            # Create generator for this format
            generator = EnhancedReportGenerator(config)
            
            # Generate report
            output_path = f"{base_output_path}.{fmt.value}"
            result = generator.generate_report(summaries, goal, output_path)
            
            if result:
                results[fmt] = result
        
        return results

# Backward compatibility functions
def generate_report(
    summaries: List[Dict[str, Any]],
    goal: str,
    output_path: str = "litlens_summary_report.txt",
    format: str = "txt",
    return_as_string: bool = False
) -> Optional[str]:
    """Backward compatible report generation function."""
    logger.info("Generating report...")
    
    # Convert format string to enum
    format_map = {
        "txt": ReportFormat.TEXT,
        "md": ReportFormat.MARKDOWN,
        "html": ReportFormat.HTML,
        "json": ReportFormat.JSON
    }
    
    report_format = format_map.get(format.lower(), ReportFormat.TEXT)
    
    # Create configuration
    config = ReportConfig(
        format=report_format,
        include_toc=True,
        include_metadata=True,
        include_statistics=True
    )
    
    # Generate report
    generator = EnhancedReportGenerator(config)
    
    if return_as_string:
        return generator.generate_report(summaries, goal, return_as_string=True)
    else:
        return generator.generate_report(summaries, goal, output_path)


def generate_markdown_report(summaries: List[Dict[str, Any]], goal: str) -> str:
    """Backward compatible markdown report generation."""
    config = ReportConfig(
        format=ReportFormat.MARKDOWN,
        include_toc=True,
        include_metadata=True
    )
    
    generator = EnhancedReportGenerator(config)
    return generator.generate_report(summaries, goal, return_as_string=True)


# Additional utility functions
def validate_summaries(summaries: List[Dict[str, Any]]) -> bool:
    """Validate summaries data structure."""
    if not isinstance(summaries, list):
        return False
    
    for paper in summaries:
        if not isinstance(paper, dict):
            return False
        
        required_keys = ['title', 'summary']
        if not all(key in paper for key in required_keys):
            return False
    
    return True


def get_report_statistics(summaries: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Get statistics about the summaries."""
    stats = {
        "total_papers": len(summaries),
        "total_sections": 0,
        "total_words": 0,
        "papers_with_metadata": 0,
        "unique_journals": set(),
        "year_range": None
    }
    
    years = []
    
    for paper in summaries:
        # Count sections
        chunks = paper.get("chunks", [])
        stats["total_sections"] += len(chunks)
        
        # Count words
        summary = paper.get("summary", "")
        stats["total_words"] += len(summary.split())
        
        # Check metadata
        metadata = paper.get("metadata", {})
        if metadata:
            stats["papers_with_metadata"] += 1
            
            if metadata.get("journal"):
                stats["unique_journals"].add(metadata["journal"])
            
            if metadata.get("year"):
                try:
                    years.append(int(metadata["year"]))
                except (ValueError, TypeError):
                    pass
    
    # Convert journals set to count
    stats["unique_journals"] = len(stats["unique_journals"])
    
    # Calculate year range
    if years:
        stats["year_range"] = (min(years), max(years))
    
    return stats
